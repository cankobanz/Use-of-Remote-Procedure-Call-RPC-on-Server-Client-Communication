/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
 /* @file part_b_server.c
 * @author Can Koban
 *
 * @brief Project 1 par_b solution is following. Server side is doing exactly same thing in the part_a.
 * However, in remote procedure control aim is serving many clients from far away. Client sends its inputs and path
 * for the executable blackbox. Then, server takes them and do same thing in the part_a but it does not write to file.
 * Rather than that, it sends back the output to client and client part writes to the file when the main function ends. 
 * @Reference: Implentatiton is learned from PS 6 notes, especially from rpc example.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/wait.h>
#include <errno.h>
#include <fcntl.h>

#include "part_b.h"

char **
part_b_1_svc(inputs *argp, struct svc_req *rqstp)
{
	static char * result;
	
	int     p2c[2], c2p[2];
    pid_t   pid;
    char    w_buf[2048], r_buf[2048];
    /* 
    * Two pipe is created.
    * p2p: Parent to child pipe. p2c[0]: Read end for child. p2c[1]:Write end for parent.
    * c2p: Child to parent pipe. c2p[0]: Read end for parent. c2p[1]:Write end for child.
    */
    if(pipe(p2c)==-1){
        fprintf(stderr, "pipe() Error: %s\n",strerror(errno));
        exit(1);
    }  

    if(pipe(c2p)==-1){
        fprintf(stderr, "pipe() Error: %s\n",strerror(errno));
        exit(1);
    }

    if((pid=fork()) == -1) {
        fprintf(stderr, "fork() failed.\n");
        exit(1);
    }

    //Parent process
    if(pid > 0) {

        if(close(p2c[0])==-1){// Parent will not read from p2c
        fprintf(stderr, "close() Error: %s\n",strerror(errno));
        exit(1);
        }    
        if(close(c2p[1])==-1){// Parent will not write to c2p
        fprintf(stderr, "close() Error: %s\n",strerror(errno));
        exit(1);
        }
 
        char s1[1024];
        char s2[1024];

        /*
        * argp->a and argp->b are input numbers come from the client
        * They are concaneted to make this structure: "a b\n"
        */
        sprintf(s1, "%d", argp->a);
        sprintf(s2, " %d\n", argp->b);
 
        strcat(s1, s2);
        strcpy(w_buf,s1);

        //Empty the read buffer to prevent debugs
        memset(r_buf, 0, 2048);

        //Inputs are sent to child through p2c pipe.
        if(write(p2c[1], w_buf, strlen(w_buf))==-1){
        fprintf(stderr, "write() Error: %s\n",strerror(errno));
        exit(1);
        } 
        /*For the reader it is better to continue from child process from here,
        * since parent will wait here until something is written to the c2p[0].
        */        

        //Parent reads the output from coming from child.
        if(read(c2p[0], r_buf, sizeof(r_buf))==-1){
        fprintf(stderr, "read() Error: %s\n",strerror(errno));
        exit(1);
        }

        //Wait child to end. Record termination state of child (actually blackbox) to wstatus.
        int wstatus;
        if(wait(&wstatus)==-1){
        fprintf(stderr, "wait() Error: %s\n",strerror(errno));
        exit(1);
        }

        //Empty the temp buffer and result to prevent bugs.
       	char temp_buf[2000];
       	memset(temp_buf, 0, 2000);
       	result="";

        //According to termination state of child print SUCCESS: or FAIL:
        //Note that, result will be returned to the client.
        if (WIFEXITED(wstatus)){
	        if(WEXITSTATUS(wstatus)==0){
   	            sprintf(temp_buf, "SUCCESS:\n%s",r_buf);
	            result=temp_buf;
	        }else{
	            sprintf(temp_buf,"FAIL:\n%s", r_buf);
	            result=temp_buf;
	        }
		}
    }
    else {
        //Redirect stdin to p2c[0] to scanf() inputs. Scanf is come from blackbox (it is guarenteed.)
        if(dup2(p2c[0], STDIN_FILENO)==-1){
        fprintf(stderr, "dup2() Error: %s\n",strerror(errno));
        exit(1);
        }

        //Redirect stdout to c2p[1] to send output to parent.  
        if(dup2(c2p[1], STDOUT_FILENO)==-1){
        fprintf(stderr, "dup2() Error: %s\n",strerror(errno));
        exit(1);
        }
        //Redirect stderr to c2p[1] to send error to parent.
        if(dup2(c2p[1], STDERR_FILENO)==-1){
        fprintf(stderr, "dup2() Error: %s\n",strerror(errno));
        exit(1);
        }

        // Child will not use any of the pipes. They are related ends redirected above. Close all.
        if(close(c2p[0])==-1){
        fprintf(stderr, "close() Error: %s\n",strerror(errno));
        exit(1);
        }
        if(close(c2p[1])==-1){
        fprintf(stderr, "close() Error: %s\n",strerror(errno));
        exit(1);
        }
        if(close(p2c[0])==-1){
        fprintf(stderr, "close() Error: %s\n",strerror(errno));
        exit(1);
        }
        if(close(p2c[1])==-1){
        fprintf(stderr, "close() Error: %s\n",strerror(errno));
        exit(1);
        }

        //Here, execl() replace everything with the scripts of blackbox. It's path come from command line.
        if(execl(argp->blackboxPath,argp->blackboxPath, NULL)==-1){
        fprintf(stderr, "execl() Error: %s\n",strerror(errno));
        exit(1);
        }

    }

	return &result;
}
